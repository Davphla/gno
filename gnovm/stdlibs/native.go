// This file is autogenerated; do not edit.
// To regenerate it, run `go generate` or `go run ./internal/stdgen`
// from @/stdlibs.

package stdlibs

import (
	"reflect"

	gno "github.com/gnolang/gno/gnovm/pkg/gnolang"
	lib0 "github.com/gnolang/gno/gnovm/stdlibs/crypto/sha256"
	lib1 "github.com/gnolang/gno/gnovm/stdlibs/math"
)

var nativeFuncs = [...]nativeFunc{
	{
		"crypto/sha256",
		"Sum256",

		[]gno.FieldTypeExpr{
			{Name: gno.N("p0"), Type: gno.X("[]byte")},
		},
		[]gno.FieldTypeExpr{
			{Name: gno.N("r0"), Type: gno.X("[]byte")},
		},
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  []byte
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			gno.Gno2GoValue(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV, rp0)

			r0 := lib0.Sum256(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(r0),
			))
		},
	},
	{
		"math",
		"Float32bits",

		[]gno.FieldTypeExpr{
			{Name: gno.N("p0"), Type: gno.X("float32")},
		},
		[]gno.FieldTypeExpr{
			{Name: gno.N("r0"), Type: gno.X("uint32")},
		},
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  float32
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			gno.Gno2GoValue(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV, rp0)

			r0 := lib1.Float32bits(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(r0),
			))
		},
	},
	{
		"math",
		"Float32frombits",

		[]gno.FieldTypeExpr{
			{Name: gno.N("p0"), Type: gno.X("uint32")},
		},
		[]gno.FieldTypeExpr{
			{Name: gno.N("r0"), Type: gno.X("float32")},
		},
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  uint32
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			gno.Gno2GoValue(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV, rp0)

			r0 := lib1.Float32frombits(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(r0),
			))
		},
	},
	{
		"math",
		"Float64bits",

		[]gno.FieldTypeExpr{
			{Name: gno.N("p0"), Type: gno.X("float64")},
		},
		[]gno.FieldTypeExpr{
			{Name: gno.N("r0"), Type: gno.X("uint64")},
		},
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  float64
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			gno.Gno2GoValue(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV, rp0)

			r0 := lib1.Float64bits(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(r0),
			))
		},
	},
	{
		"math",
		"Float64frombits",

		[]gno.FieldTypeExpr{
			{Name: gno.N("p0"), Type: gno.X("uint64")},
		},
		[]gno.FieldTypeExpr{
			{Name: gno.N("r0"), Type: gno.X("float64")},
		},
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  uint64
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			gno.Gno2GoValue(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV, rp0)

			r0 := lib1.Float64frombits(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(r0),
			))
		},
	},
}
