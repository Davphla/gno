* https://miro.com/app/board/uXjVKMHO3Xg=/

1. bootstrap from existing language tests.
2. gnolang.proto (see miro screenshot)
  - auto generated from amino
  - 

Ideas:
 - How to build a VM interpreter.
 - The last interpreter you'll ever need.
 - Gno ....
 - How to run untrusted (go) code safely.

Problem:
 * Massive userbase
 * Each user can submit code
 * Run untrusted code?
   -> go playground; uses docker.

     -> // The sandbox program is an HTTP server that receives untrusted
	// linux/amd64 binaries in a POST request and then executes them in
	// a gvisor sandbox using Docker, returning the output as a response
	// to the POST.

     -> in other words, the 

Our mission is to bring programming literacy and self sustainability to the world.



 * massive user safety
 * gas counting
 * allocation limits
 * language API interfaces
 * determinism
 * native support
 * auto-persistence

 * games
 * message routing
 * productivity scripting
 * CDN/edge scripting
 * smart contracts

MASSIVE USER SAFETY
 * Need for gas counting and allocations.
 * 

GNO VMâ€™s native go API binding is a superior feature than solidity  EVM in the edge computing and CDN case

EMBEDDED SCRIPTING LANGUAGES

 * LUA

GNO VM is not optimized; implemented as a standard reference implementation.

OTHER

 * Could target other languages.
 * Possibly with dynamic type generation.

FUTURE WORK

 * synchronous garbage collector
 * our own type checking
 * JOESON

=======================

Title: The GNO VM - massive multi-user scripting for games and more.

Abstract: The GNO VM is a virtual machine created to interpret Go programs in a
massive multi-user environment with applications for scripting in MMO games,
collaboration tools, CDN edge servers, and more. A survey of related solutions
are presented, their drawbacks; and an overview of the GNO VM and the
platform we are building on the GNO VM.

Problem:
- massive-multi-user scripting is difficult

Massive Multi User Scripting
- Trad client-side (JS) scripting (not secure)
- Trad server-side scripting (resource allocation problem)
- Use cases: Games
  - e.g. Second Life & LSL
  - e.g. Stationeers & "MIPS"
  - e.g. Rust & logic circuits
  - e.g. Minecraft ComputerCraft mod & Lua
  - Funny: Minecraft simulated CPU, technically
  - NOT: Unity engine & C#
  - NOT: World of Warcraft & LUA (only for UI)
- Use Cases: Collaboration tools
- Use Cases: CDN Edge servers
- Use cases: Smart Contracts

Our Requirements
- cpu cycle (gas) counting
- memory allocation limits
- determinism (for replication)
- ease of interoperability
- type safety
- concurrency

Desired Goal: Massive Multi User OS
- interoperate with user code via user package imports
- example; Alice calls Bob's declared function
- scale to millions of users
- short transactional function calls
- also long running function calls

Incomplete solutions: Lua, embedded scripting languages
- cpu cycle counting
- memory allocation

Incomplete solutions: Ethereum, smart contract platforms.
- EVM/Solidity is limited
- other based on WASM (and usually Rust), but limited

Incomplete solution: Go over WASM
- still work in progress
- plugins need to be loaded AND unloaded
- limitations on plugins? layload size?
- cpu-cycle/memory management still needed
- NOTE: tinygo possible, but not complete

Non-solution: Go Playground
- Sends executable to a docker container (performance)

Solution: GNO VM
- 

Design choices:
- 

Features:
- 

Learnings:
- 

Memristors!

Also, gno.land
- 












