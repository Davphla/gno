package upgradeable

import (
	"errors"
	"std"

	"gno.land/p/demo/ownable"
)

// ContractProxy is a proxy that delegates calls to an implementation contract
// It stores data but delegates logic to the implementation
type ContractProxy struct {
	*ownable.Ownable
	implementation string // Path to the implementation realm
	data           Any    // Contract state
}

// NewContractProxy creates a new proxy with the caller as owner
func NewContractProxy() *ContractProxy {
	return &ContractProxy{
		Ownable: ownable.New(),
	}
}

// SetImplementation updates the implementation realm path
// Only the owner can update the implementation
func (p *ContractProxy) SetImplementation(implementationPath string) error {
	if !p.CallerIsOwner() {
		return ownable.ErrUnauthorized
	}

	// Check if the implementation exists
	// Note: In a real implementation, we would validate that the realm exists
	// and implements the required interface

	oldImpl := p.implementation
	p.implementation = implementationPath

	std.Emit(
		EventImplementationUpgraded,
		"from", oldImpl,
		"to", implementationPath,
	)

	return nil
}

// Implementation returns the current implementation path
func (p *ContractProxy) Implementation() string {
	return p.implementation
}

// GetState returns the contract state
func (p *ContractProxy) GetState() Any {
	return p.data
}

// SetState updates the contract state
// Only the implementation can update the state
func (p *ContractProxy) SetState(newState Any) error {
	// In a real implementation, we would check that the caller
	// is the implementation contract

	p.data = newState
	return nil
}

// Example of a delegate call helper
// This would call a function on the implementation contract
// and provide it access to the state
func (p *ContractProxy) DelegateCall(method string, args ...Any) (Any, error) {
	if p.implementation == "" {
		return nil, ErrImplementationNotSet
	}

	// In a real implementation, this would use Gno's inter-realm call mechanism
	// to invoke the method on the implementation contract
	// and pass along the proxy's state

	// Placeholder:
	// result := std.Call(p.implementation, method, append([]interface{}{p.data}, args...))

	return nil, errors.New("delegate call not implemented")
}

// Implementation contract interface
// This is conceptual and would be defined by developers
type ImplementationContract interface {
	Initialize(state Any) error
	Execute(method string, args ...Any) (Any, error)
}

// Contract implementation example
// The proxy delegates to an implementation that might be upgraded
type ContractImplementation struct {
	// Implementation details
}

// Initialize sets up the implementation with state from the proxy
func (i *ContractImplementation) Initialize(state Any) error {
	// Setup code
	return nil
}

// Execute handles method calls from the proxy
func (i *ContractImplementation) Execute(method string, args ...Any) (Any, error) {
	// Implementation logic
	return nil, nil
}
